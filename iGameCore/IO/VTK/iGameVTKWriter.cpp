#include "iGameVTKWriter.h"

IGAME_NAMESPACE_BEGIN
bool VTKWriter::GenerateBuffers()
{
	m_Buffers.resize(10, nullptr);
	switch (m_DataObject->GetDataObjectType())
	{
	case IG_SURFACE_MESH:
		m_SurfaceMesh = DynamicCast<SurfaceMesh>(m_DataObject);
		WriteWithSurfaceMeshType();
		break;
	case IG_VOLUME_MESH:
		UnstructuredMesh::TransferVolumeMeshToUnstructuredMesh(DynamicCast<VolumeMesh>(m_DataObject), m_UnstructuredMesh);
		WriteWithUnstructuredMeshType();
		break;
	case IG_UNSTRUCTURED_MESH:
		m_UnstructuredMesh = DynamicCast<UnstructuredMesh>(m_DataObject);
		WriteWithUnstructuredMeshType();
		break;
	case IG_STRUCTURED_MESH:
		m_StructuredMesh = DynamicCast<StructuredMesh>(m_DataObject);
		WriteWithStructuredMeshType();
		break;
	default:
		return false;
	}
	return true;
}
const void VTKWriter::WriteHeaderToBuffer()
{
	auto buffer = CharArray::New();
	std::string data = "# vtk DataFile Version 3.0\nGenerated by iGameMeshLab\n";
	if (m_FileType == IGAME_ASCII) {
		data += "ASCII\nDATASET ";
	}
	else {
		data += "BINARY\nDATASET ";
	}
	switch (m_DataObject->GetDataObjectType())
	{
	case IG_SURFACE_MESH:
		data += "POLYDATA\n";
		break;
	case IG_VOLUME_MESH:
	case IG_UNSTRUCTURED_MESH:
		data += "UNSTRUCTURED_GRID\n";
		break;
	case IG_STRUCTURED_MESH:
		data += "STRUCTURED_GRID\n";
		break;
	default:
		return;
	}
	AddStringToBuffer(data, buffer);
	m_TemporaryBuffers.emplace_back(buffer);
}

const void VTKWriter::WriteWithUnstructuredMeshType()
{
	WriteHeaderToBuffer();
	WritePointsToBuffer(m_UnstructuredMesh->GetPoints());
	WriteCellsToBuffer(m_UnstructuredMesh->GetCells());
	WriteCellsTypeToBuffer();
	WritePointsAttributesToBuffer(m_UnstructuredMesh->GetAttributeSet());
	WriteCellsAttributesToBuffer(m_UnstructuredMesh->GetAttributeSet());
	this->TransferBuffer();
}
const void VTKWriter::WriteWithStructuredMeshType()
{
	WriteHeaderToBuffer();
	WritePointsToBuffer(m_StructuredMesh->GetPoints());
	WritePointsAttributesToBuffer(m_StructuredMesh->GetAttributeSet());
	WriteCellsAttributesToBuffer(m_StructuredMesh->GetAttributeSet());
	this->TransferBuffer();
}
const void VTKWriter::WriteWithSurfaceMeshType()
{
	WriteHeaderToBuffer();
	WritePointsToBuffer(m_SurfaceMesh->GetPoints());
	WriteCellsToBuffer(m_SurfaceMesh->GetFaces());
	WritePointsAttributesToBuffer(m_SurfaceMesh->GetAttributeSet());
	WriteCellsAttributesToBuffer(m_SurfaceMesh->GetAttributeSet());
	this->TransferBuffer();
}
const void VTKWriter::WriteDimensionSizeToBuffer()
{
	auto buffer = CharArray::New();

	std::string data = "DIMENSIONS";
	auto dimensionSize = m_StructuredMesh->GetDimensionSize();
	for (int i = 0; i < 3; i++) {
		data += " " + std::to_string(dimensionSize[i]);
	}
	data += '\n';
	AddStringToBuffer(data, buffer);
	m_TemporaryBuffers.emplace_back(buffer);
}

const void VTKWriter::WritePointsToBuffer(Points::Pointer Points)
{
	if (m_DataObject->GetDataObjectType() == IG_STRUCTURED_MESH) {
		WriteDimensionSizeToBuffer();
	}
	auto buffer = CharArray::New();
	int VertexNum = Points ? Points->GetNumberOfPoints() : 0;
	std::string data = "POINTS " + std::to_string(VertexNum) + " float\n";
	AddStringToBuffer(data, buffer);
	m_TemporaryBuffers.emplace_back(buffer);
	if (m_FileType == IGAME_ASCII) {
		std::vector<CharArray::Pointer> tmpBuffrs(m_MaxThreadSize);
		for (int i = 0; i < m_MaxThreadSize; i++) {
			tmpBuffrs[i] = CharArray::New();  
		}
		auto func = [&](igIndex start, igIndex end, int id) -> void {
			Point p;
			auto& buffer = tmpBuffrs[id];
			for (int i = start; i < end; i++) {
				p = Points->GetPoint(i);
				for (int j = 0; j < 3; j++) {
					if (j)buffer->AddValue(' ');
					AddStringToBuffer(std::to_string(p[j]), buffer);
				}
				buffer->AddValue('\n');
			}
		};
		ThreadPool::parallelFor(0, VertexNum, m_MaxThreadSize, func);
		for (int i = 0; i < tmpBuffrs.size(); i++) {
			if (tmpBuffrs[i]->GetNumberOfValues()) {
				m_TemporaryBuffers.emplace_back(tmpBuffrs[i]);
			}
		}
	}
	else {

	}
}
const void VTKWriter::WriteCellsToBuffer(CellArray::Pointer Cells)
{
	int CellNum = Cells ? Cells->GetNumberOfCells() : 0;
	if (!CellNum) {
		return;
	}
	auto buffer = CharArray::New();
	std::string data;
	if (m_DataObject->GetDataObjectType() == IG_SURFACE_MESH) {
		data = "POLYGONS " + std::to_string(CellNum) + ' ';
	}
	else {
		data = "CELLS " + std::to_string(CellNum) + ' ';

	}
	size_t idSize = Cells->GetNumberOfCellIds() + Cells->GetNumberOfCells();
	data += std::to_string(idSize) + '\n';
	AddStringToBuffer(data, buffer);
	m_TemporaryBuffers.emplace_back(buffer);
	igIndex cellNum = Cells->GetNumberOfCells();
	if (m_FileType == IGAME_ASCII) {
		std::vector<CharArray::Pointer> tmpBuffrs(m_MaxThreadSize);
		for (int i = 0; i < m_MaxThreadSize; i++) {
			tmpBuffrs[i] = CharArray::New();
		}
		auto func = [&](igIndex start, igIndex end, int id) -> void {
			auto& buffer = tmpBuffrs[id];
			igIndex vcnt = 0;
			igIndex vhs[IGAME_CELL_MAX_SIZE] = { 0 };
			for (igIndex i = start; i < end; i++) {
				vcnt = Cells->GetCellIds(i, vhs);
				AddStringToBuffer(std::to_string(vcnt), buffer);
				for (int j = 0; j < vcnt; j++) {
					buffer->AddValue(' ');
					AddStringToBuffer(std::to_string(vhs[j]), buffer);
				}
				buffer->AddValue('\n');
			}
		};
		ThreadPool::parallelFor(0, CellNum, m_MaxThreadSize, func);
		for (int i = 0; i < tmpBuffrs.size(); i++) {
			if (tmpBuffrs[i]->GetNumberOfValues()) {
				m_TemporaryBuffers.emplace_back(tmpBuffrs[i]);
			}
		}
	}
	else {

	}
}
const void VTKWriter::WriteCellsTypeToBuffer()
{
	auto CellsType = m_UnstructuredMesh->GetCellTypes();
	int CellNum = CellsType ? CellsType->GetNumberOfValues() : 0;
	if (!CellNum)return;
	auto buffer = CharArray::New();
	std::string data = "CELL_TYPES " + std::to_string(CellNum) + '\n';
	AddStringToBuffer(data, buffer);
	igIndex vtkType;
	for (int i = 0; i < CellNum; i++) {
		switch ((int)CellsType->GetValue(i))
		{
		case IG_TRIANGLE:
			vtkType = VTKAbstractReader::TRIANGLE;
			break;
		case IG_QUAD:
			vtkType = VTKAbstractReader::QUAD;
			break;
		case IG_POLYGON:
			vtkType = VTKAbstractReader::POLYGON;
			break;
		case IG_TETRA:
			vtkType = VTKAbstractReader::TETRA;
			break;
		case IG_HEXAHEDRON:
			vtkType = VTKAbstractReader::HEXAHEDRON;
			break;
		case IG_PRISM:
			vtkType = VTKAbstractReader::WEDGE;
			break;
		case IG_PYRAMID:
			vtkType = VTKAbstractReader::PYRAMID;
			break;
		case IG_POLYHEDRON:
			vtkType = VTKAbstractReader::POLYHEDRON;
			break;
		default:
			vtkType = VTKAbstractReader::T0;
			break;
		}
		if (m_FileType == IGAME_ASCII) {
			AddStringToBuffer(std::to_string(vtkType), buffer);
			buffer->AddValue('\n');
		}
		else {

		}
	}
	m_TemporaryBuffers.emplace_back(buffer);
}
std::string VTKWriter::GenerateAttributeHeader(AttributeSet::Attribute attribute)
{
	auto array = attribute.pointer;
	const std::string originalName = array->GetName();
	size_t encodedLength = originalName.length() * 3;
	std::vector<char> buffer(encodedLength + 1);
	int actualLength = EncodeString(buffer.data(), originalName.c_str());
	std::string ArrayName(buffer.data(), actualLength);
	std::string data;
	std::string type;
	if (array->GetArrayTypedSize() == sizeof(float)) {
		type = " float";
	}
	else {
		type = " double";
	}
	switch (attribute.type)
	{
	case IG_SCALAR:
		return "SCALARS " + ArrayName + type + ' ' + std::to_string(array->GetDimension()) + "\nLOOKUP_TABLE default\n";
	case IG_VECTOR:
		return "VECTORS " + ArrayName + type + '\n';
	case IG_TENSOR:
		return "TENSORS " + ArrayName + type + '\n';
	case IG_NORMAL:
		return "NORMALS " + ArrayName + type + '\n';
	default:
		return "SCALARS " + ArrayName + type + '\n';
	}
}

const void VTKWriter::WriteAttributesToBuffer(ElementArray<AttributeSet::Attribute>::Pointer AttributeData)
{
	for (int i = 0; i < AttributeData->GetNumberOfElements(); i++)
	{
		auto attribute = AttributeData->GetElement(i);
		auto array = attribute.pointer;
		auto buffer = CharArray::New();
		AddStringToBuffer(GenerateAttributeHeader(attribute), buffer);
		m_TemporaryBuffers.emplace_back(buffer);
		WriteArrayToBuffer(array);
	}
}
const void VTKWriter::WritePointsAttributesToBuffer(AttributeSet::Pointer AttributeSet)
{
	if (AttributeSet == nullptr)return;
	auto PointData = AttributeSet->GetAllPointAttributes();
	if (!PointData || PointData->GetNumberOfElements() == 0)return;
	auto buffer = CharArray::New();
	int VertexNum = m_UnstructuredMesh->GetNumberOfPoints();
	std::string data = "POINT_DATA " + std::to_string(VertexNum) + "\n";
	AddStringToBuffer(data, buffer);
	m_TemporaryBuffers.emplace_back(buffer);
	WriteAttributesToBuffer(PointData);
	return;
}
const void VTKWriter::WriteCellsAttributesToBuffer(AttributeSet::Pointer AttributeSet)
{
	if (AttributeSet == nullptr)return;
	auto CellData = AttributeSet->GetAllCellAttributes();
	if (!CellData || CellData->GetNumberOfElements() == 0)return;
	auto buffer = CharArray::New();
	int CellNum = CellData->GetElement(0).pointer ? CellData->GetElement(0).pointer->GetNumberOfElements() : 0;
	std::string data = "CELL_DATA " + std::to_string(CellNum) + '\n';
	AddStringToBuffer(data, buffer);
	m_TemporaryBuffers.emplace_back(buffer);
	WriteAttributesToBuffer(CellData);
}
const void VTKWriter::WriteArrayToBuffer(ArrayObject::Pointer array)
{

	int Num = array->GetNumberOfElements();
	int Component = array->GetDimension();
	std::string data;
	auto buffer = CharArray::New();
	if (m_FileType == IGAME_ASCII) {

		std::vector<CharArray::Pointer> tmpBuffrs(m_MaxThreadSize);
		for (int i = 0; i < m_MaxThreadSize; i++) {
			tmpBuffrs[i] = CharArray::New();  // 每个线程分配独立的缓冲区
		}
		auto func = [&](igIndex start, igIndex end, int id) -> void {
			auto& buffer = tmpBuffrs[id];
			double values[16];
			for (int i = start; i < end; i++) {
				array->GetElement(i, values);
				for (int j = 0; j < Component; j++) {
					if (j)buffer->AddValue(' ');
					AddStringToBuffer(std::to_string(values[j]), buffer);
				}
				buffer->AddValue('\n');
			}
		};
		ThreadPool::parallelFor(0, Num, m_MaxThreadSize, func);
		for (int i = 0; i < tmpBuffrs.size(); i++) {
			if (tmpBuffrs[i]->GetNumberOfValues()) {
				m_TemporaryBuffers.emplace_back(tmpBuffrs[i]);
			}
		}
	}
	else {

	}
}

IGAME_NAMESPACE_END